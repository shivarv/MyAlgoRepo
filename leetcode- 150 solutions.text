https://leetcode.com/problems/maximum-subarray/
class Solution {
    public int maxSubArray(int[] nums) {
        int sum = nums[0];
        int currentSum = nums[0];
        for(int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            sum = Math.max(currentSum, sum);
        }
        return sum;
    }
}


https://leetcode.com/problems/subarray-sum-equals-k/

class Solution {
    public int subarraySum(int[] nums, int k) {
        int countOfSubArray = 0;
        int sum = 0;
        Map<Integer, Integer> numsMap = new HashMap<Integer, Integer>();
        for(int i = 0 ; i < nums.length; i++) {
            sum += nums[i];
            if(sum == k) {
                countOfSubArray++;
            }
            //it has to be sum - k only then numbers between it will be sum to k
            if(numsMap.containsKey(sum - k)) {
                countOfSubArray += numsMap.get(sum - k);
            }
            numsMap.put(sum, numsMap.getOrDefault(sum, 0) + 1);
        }
        return countOfSubArray;
    }
}

https://leetcode.com/problems/subarray-sums-divisible-by-k/
    class Solution {
        public int subarraysDivByK(int[] nums, int k) {
            int totalCount = 0;
            int sum = 0;
            Map<Integer, Integer> numsMap = new HashMap<Integer, Integer>();
            for(int i = 0 ;i < nums.length; i++) {
                sum = ((sum + nums[i]) % k + k) % k;
                if(sum == 0) {
                    totalCount++;
                }
				//this means if already sum exists
                if(numsMap.containsKey(sum)) {
                    totalCount = totalCount + numsMap.get(sum);
                }
                numsMap.put(sum, numsMap.getOrDefault(sum, 0) + 1);
                
                
            }
            return totalCount;
        }
    }
	
https://leetcode.com/problems/product-of-array-except-self/
	
	class Solution {
    public int[] productExceptSelf(int[] nums) {
        int preProd = 1;
        int postProd = 1;
        int output[] = new int[nums.length];
        for(int i = 0; i < nums.length; i++) {
            output[i] = preProd;
            preProd *= nums[i];
        }
        for(int i = nums.length - 1; i >= 0; i--) {
            output[i] = output[i] * postProd;
            postProd *= nums[i];
        }
        return output;
    }
}


https://leetcode.com/problems/merge-intervals/
static ArrayList<int[]> mergeOverlap(int[][] arr) {

        // Sort intervals based on start values
        Arrays.sort(arr, (a, b) -> Integer.compare(a[0], b[0]));

        ArrayList<int[]> res = new ArrayList<>();
        res.add(new int[]{arr[0][0], arr[0][1]});

        for (int i = 1; i < arr.length; i++) {
            int[] last = res.get(res.size() - 1);
            int[] curr = arr[i];

            // If current interval overlaps with the last merged interval,
            // merge them
            if (curr[0] <= last[1])
                last[1] = Math.max(last[1], curr[1]);
            else
                res.add(new int[]{curr[0], curr[1]});
        }

        return res;
    }
	
	https://leetcode.com/problems/insert-interval/

	
	
	https://leetcode.com/problems/trapping-rain-water/

	// key point on why this works.. because Min(lmax or rMax) only be considered for the amount cal
	// left <= right
	// lMax <= rMax
	//for lMax greater ,calculate using left, rMax greater calculate using right
	class Solution {
    public int trap(int[] height) {
        int waterCount = 0;
        int lMax = height[0];
        int rMax = height[height.length - 1];
        int left = 1;
        int right = height.length - 1;
        while(left <= right) {
            if (lMax <= rMax) {
                if (height[left] < lMax) {
                    waterCount += lMax - height[left];
                }
                lMax = Math.max(lMax, height[left]);
                left++;
            } else {
                if (height[right] < rMax) {
                    waterCount += rMax - height[right];
                }
                rMax = Math.max(rMax, height[right]);
                right--;
            }
        }
        return waterCount;
    }
}

https://leetcode.com/problems/next-permutation/

class Solution {
    private void reverse(int[] nums, int left , int right) {
        
        while(left < right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }

    public void nextPermutation(int[] nums) {
        int firstNonIncrementingIndex = -1;
        //
        for(int i = nums.length - 2; i >= 0; i--) {
            if(nums[i] < nums[i + 1]) {
                firstNonIncrementingIndex = i;
                break;
            }
        }

        System.out.println(firstNonIncrementingIndex);
        if(firstNonIncrementingIndex == -1) {
            reverse(nums, 0 , nums.length - 1);
            return;
        }
        for(int i = nums.length - 1;i > firstNonIncrementingIndex; i--) {
            if(nums[i] > nums[firstNonIncrementingIndex]) {
                int temp = nums[i];
                nums[i] = nums[firstNonIncrementingIndex];
                nums[firstNonIncrementingIndex] = temp;
                break;
            }
        }
                System.out.println(Arrays.toString(nums));
                            reverse(nums, firstNonIncrementingIndex + 1, nums.length - 1);
        System.out.println(Arrays.toString(nums));
    }
}

https://leetcode.com/problems/rotate-array/

class Solution {
    public void rotate(int[] nums, int k) {
        if(nums.length <= 1) {
            return;
        }
        k = k % nums.length;
        reverseArray(nums, 0, nums.length - 1);
        reverseArray(nums, 0, k -1);
        reverseArray(nums, k, nums.length - 1);
        
    }

    private void reverseArray(int[] nums, int start, int end) {
        while(start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}


https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

class Solution {
    public int maxProfit(int[] prices) {
        int buy = 0;
        int sell = 1;
        int profit = 0;
        for(int i = 1; i < prices.length; i++ ) {
            profit = Math.max(profit, prices[sell] - prices[buy]);
            if(prices[sell] < prices[buy]) {
                buy = sell;
            }
            sell++;
        }
        return profit;
    }
}
//my approach
public int maxProfit(int[] prices) {
        int buy = prices[0];
        int profit = 0;
        for(int i = 1; i < prices.length; i++) {
            profit = Math.max(profit, prices[i] - buy);
            buy = Math.min(buy, prices[i]);
        }
        return profit;
}




https://leetcode.com/problems/majority-element/

// if we are asked for no spacecomplexity
//sort the array
//return the n/ 2 element..for 1 , 2 , 2, 4...if sorted n/ 2 = arr[2] = 2, if its 1, 2 , 2 .. n/ 2 = 1..arr[1] = 2
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> countMap = new HashMap<Integer, Integer>();
        int countValue = 0 ;
        // for 4 , half value is more than 2..for 3 ,half value is more than 1
        int halfValue = nums.length  % 2 == 0 ? nums.length / 2 : (nums.length - 1) / 2;
        for(int i = 0; i < nums.length; i++) {
            countValue = countMap.getOrDefault(nums[i], 0) + 1;
            if(countValue > halfValue) {
                return nums[i];
            }
            countMap.put(nums[i], countValue);
        }
        return -1;
    }
}

https://leetcode.com/problems/find-the-duplicate-number/

class Solution {
    public int findDuplicate(int[] nums) {
        //flyod's cycle
        int slowPointer = 0;
        int fastPointer = 0;
        int anotherSlowPointer = 0;
        // this logic gives the intersection of fastPointer and slowPointer
        while(true) {
            slowPointer = nums[slowPointer];
            fastPointer = nums[nums[fastPointer]];
            if(slowPointer == fastPointer) {
                break;
            }
        }
        //this gives us to identify the start of loop
        //the start of loop is the number 
        while(anotherSlowPointer != fastPointer) {
            anotherSlowPointer = nums[anotherSlowPointer];
            fastPointer = nums[fastPointer];
        }
        return anotherSlowPointer;

    }
}

class Solution {
    public int findDuplicate(int[] nums) {
        HashMap<Integer, Boolean> numsMap = new HashMap<Integer, Boolean>();
        for(int i = 0; i < nums.length;i++) {
            if(numsMap.containsKey(nums[i])) {
                return nums[i];
            }
            numsMap.put(nums[i], true);
        }
        return -1;
    }
}


https://leetcode.com/problems/set-matrix-zeroes/

//optimal solution is more better .

class Solution {
    public void setZeroes(int[][] matrix) {
        Set<Integer> xSet = new TreeSet<Integer>();
        Set<Integer> ySet = new TreeSet<Integer>();
        for(int i = 0 ; i < matrix.length;i++) {
            for(int j = 0; j < matrix[i].length; j++) {
                if(matrix[i][j] == 0) {
                    xSet.add(i);
                    ySet.add(j);
                }
            }
        }
        for(Integer yValue: ySet) {
            for(int i = 0; i < matrix.length; i++) {
                matrix[i][yValue] = 0;
            }
        }
        for(Integer xValue: xSet) {
            for(int j = 0; j < matrix[0].length; j++) {
                matrix[xValue][j] = 0;
            }
        }
    }
}

https://leetcode.com/problems/longest-mountain-in-array/

public int longestMountain(int[] arr) {
	int max = 0;
	int peak = 0;
	int leftValley = 0;
	int rightValley = 0;
	//starts with 1 and ends before arr.length - 1
	for(int i = 1; i < arr.length - 1; ) {
		if(arr[i-1] < arr[i] && arr[i] > arr[i + 1]) {
			peak = i;
			leftValley = i;
			rightValley = i;
			while(leftValley >= 1 && arr[leftValley] > arr[leftValley - 1]) {
				leftValley--;
			}
			while(rightValley < arr.length - 1 && arr[rightValley] > arr[rightValley + 1]) {
				rightValley++;
			}
			max = Math.max(rightValley - leftValley + 1, max);
			i = rightValley + 1;
		} else {
			i++;
		}
	   
	}
	return max;
}
	
https://leetcode.com/problems/two-sum/
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> setMap = new HashMap<Integer, Integer>();
        for(int i = 0; i < nums.length;i++) {
            if(setMap.containsKey(target - nums[i])) {
                return new int[]{i, setMap.get(target - nums[i]) };
            } else {
                setMap.put(nums[i], i);
            }
        }
        return new int[]{-1, -1};
    }
}

https://leetcode.com/problems/group-anagrams/
//one other algorithm is sorting each item and then seeing everyitem which is same
class Solution {
    public static String createHash(String str) {
        int[] charSet = new int[26];
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < str.length(); i++) {
            charSet[str.charAt(i) - 'a']++;
        }
        for(int i = 0; i < 26; i++) {
            if(charSet[i] > 0) {
                sb.append((char) ('a' + i));
                sb.append(charSet[i]);
                sb.append('$');
            }
        }
        return sb.toString();
    }

    public List<List<String>> groupAnagrams(String[] strs) {
       List<List<String>> output = new ArrayList<>();
       HashMap<String, List<String>> hashMapData = new HashMap<String, List<String>>();
       for(int i = 0; i < strs.length; i++) {
            String hashString = createHash(strs[i]);
            List<String> loopOutput = hashMapData.getOrDefault(hashString, new ArrayList<String>());
            loopOutput.add(strs[i]);
            hashMapData.put(hashString, loopOutput);
       }
        for (Map.Entry<String, List<String>> entry : hashMapData.entrySet())    {
            String key = entry.getKey();
            output.add(entry.getValue());
        }
        return output;
    }
}

https://leetcode.com/problems/longest-consecutive-sequence/

class Solution {
    public int longestConsecutive(int[] nums) {
        int maxSequence = 0;
        int sequence = 1;
        HashSet<Integer> numsSet = new HashSet<Integer>();
        for(int num: nums) {
            numsSet.add(num);
        }
        //avoid for loop of nums because it can have duplicates
        //always loop through set to avoid redoing duplicate nums
        for(int num: numsSet) {
			// num - 1 check is needed because only then it makes our code is checking begining of a sequence
			// if 3 exists already and our loop is at 4, we should avoid going to check for sequence at 4
            if(!numsSet.contains(num - 1)) {
                sequence = 1;
                while(numsSet.contains(num + sequence)) {
                    sequence++;   
                }
                // we allow even 1 item
                maxSequence = Math.max(maxSequence, sequence);
            }   
        }
        return maxSequence;
    }
}


https://leetcode.com/problems/top-k-frequent-elements/

class Solution {
    public int[] topKFrequent(int[] nums, int k) {

        Map<Integer, Integer> countMap = new HashMap<>();

        // 1️⃣ Count frequency
        for (int num : nums) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }

        // 2️⃣ Create buckets (max frequency <= nums.length)
        List<List<Integer>> buckets = new ArrayList<>();

		// <= nums.length is important step , else buckets.get(freq) can throw exception
		// eg for [1] as inputs
        for (int i = 0; i <= nums.length; i++) {
            buckets.add(new ArrayList<>());
        }

        // 3️⃣ Fill buckets
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            int num = entry.getKey();
            int freq = entry.getValue();
            buckets.get(freq).add(num);
        }

        // 4️⃣ Collect top k from highest frequency
        int[] result = new int[k];
        int index = 0;

        for (int i = buckets.size() - 1; i >= 0 && index < k; i--) {
            for (int num : buckets.get(i)) {
                result[index++] = num;
                if (index == k) break;
            }
        }

        return result;
    }
}

https://leetcode.com/problems/first-unique-character-in-a-string/

class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> frequencyMap = new HashMap<Character, Integer>();
        for(int i = 0; i < s.length(); i++) {
            frequencyMap.put(s.charAt(i) , frequencyMap.getOrDefault(s.charAt(i), 0) + 1);
        }
        for(int i = 0; i < s.length(); i++) {
            if(frequencyMap.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }
}
//my other solution, feels more accurate since the space is only 26..
class Solution {
    public int firstUniqChar(String s) {
        int[] freq = new int[26]
        // Count frequency
        for (int i = 0; i < s.length(); i++) {
            freq[s.charAt(i) - 'a']++;
        }

        // Find first unique
        for (int i = 0; i < s.length(); i++) {
            if (freq[s.charAt(i) - 'a'] == 1) {
                return i;
            }
        }

        return -1;
    }
}

https://leetcode.com/problems/valid-anagram/

class Solution {
    public boolean isAnagram(String s, String t) {
        int[] charsDifference = new int[26];
        if(s.length() != t.length()) {
            return false;
        }
        for(int i = 0; i < s.length(); i++) {
            charsDifference[s.charAt(i) - 'a']++;
            charsDifference[t.charAt(i) - 'a']--;
        }
        for(int i = 0; i < 26; i++){
            if(charsDifference[i] != 0) {
                return false;
            }
        }
        return true;
    }
}

https://leetcode.com/problems/isomorphic-strings/

class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> replaceCharacterMap = new HashMap<Character, Character>();
        Map<Character, Character> reverseCharacterMap = new HashMap<Character, Character>();
        if(s.length() != t.length()) {
            return false;
        }
        
        for(int i = 0; i < s.length(); i++) {
            if(replaceCharacterMap.containsKey(s.charAt(i))) {
                if(replaceCharacterMap.get(s.charAt(i)) != t.charAt(i)) {
                    return false;
                }
            } else if(reverseCharacterMap.containsKey(t.charAt(i))) {
                
                if(reverseCharacterMap.get(t.charAt(i)) != s.charAt(i)
                ) {
                    return false;
                }
            } else {
                replaceCharacterMap.put(s.charAt(i), t.charAt(i));
                reverseCharacterMap.put(t.charAt(i), s.charAt(i));
            }
        }
        return true;
    }
}

https://leetcode.com/problems/contains-duplicate/

class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> numsSet = new HashSet<Integer>();
        for(int num: nums) {
            if(numsSet.contains(num)) {
                return true;
            }
            numsSet.add(num);
        } 
        return false;
    }
}

https://leetcode.com/problems/happy-number/

class Solution {
    HashSet<Integer> numsSeq = new HashSet<Integer>();
    public boolean isHappy(int n) {
        if(isHappyNumber(n) == 1) {
            return true;
        }
        return false;
    }

    private int isHappyNumber(int n) {
        if(numsSeq.contains(n) || n == 1) {
            return n;
        }
        numsSeq.add(n);
        int sum = 0;
        int d = 0;
        while(n > 0) {
            d = n % 10;
            sum += (d * d);
            n = n /10;
        }
        return isHappyNumber(sum);
    }
}

https://leetcode.com/problems/word-pattern/

class Solution {
    public boolean wordPattern(String pattern, String s) {
        Map<Character, String> cStringMap = new HashMap<Character, String>();
        Map<String, Character> sCharMap = new HashMap<String, Character>();
        String[] sList = s.split(" ");
        if(sList.length != pattern.length()) {
            return false;
        }
        for(int i = 0; i < pattern.length(); i++) {
            if(cStringMap.containsKey(pattern.charAt(i))) {
                if(!cStringMap.get(pattern.charAt(i)).equals(sList[i])) {
                    return false;
                }
            } else if(sCharMap.containsKey(sList[i])) {
                if(sCharMap.get(sList[i]) != pattern.charAt(i)) {
                    return false;
                }
            } else {
                cStringMap.put(pattern.charAt(i), sList[i]);
                sCharMap.put(sList[i], pattern.charAt(i));
            }
        }
        return true;
    }
}

https://leetcode.com/problems/intersection-of-two-arrays/

class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> itemsSet = new HashSet<Integer>();
        int pointer1 = 0, pointer2 = 0, l1  = nums1.length , l2 = nums2.length;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        while(pointer1 < l1 && pointer2 < l2) {
            if(nums1[pointer1] < nums2[pointer2]) {
                pointer1++;
            } else if(nums2[pointer2] < nums1[pointer1]) {
                pointer2++;
            } else {
                itemsSet.add(nums1[pointer1]);
                pointer1++;
                pointer2++;
            }
        }
        return itemsSet.stream()
                    .mapToInt(Integer::intValue)
                    .toArray();
    }
}


https://leetcode.com/problems/ransom-note/

class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character, Integer> ransomNoteMap = new HashMap<Character, Integer>();
        Map<Character, Integer> magazineMap = new HashMap<Character, Integer>();
        for(int i = 0; i < ransomNote.length(); i++) {
            ransomNoteMap.put(ransomNote.charAt(i),
            ransomNoteMap.getOrDefault(ransomNote.charAt(i), 0) + 1
            );
        }
        for(int i = 0; i < magazine.length(); i++) {
            magazineMap.put(magazine.charAt(i),
            magazineMap.getOrDefault(magazine.charAt(i), 0) + 1
            );
        }
        for (Map.Entry<Character, Integer> entry : ransomNoteMap.entrySet())     {
            Character key = entry.getKey();
            if(!magazineMap.containsKey(key) || ( magazineMap.get(key) - ransomNoteMap.get(key) < 0)) {
                return false;
            }
        }
        return true;
    }
}

https://leetcode.com/problems/design-hashmap/

class MyHashMap {
    int arr[];
    public MyHashMap() {
        arr = new int[1000];
        Arrays.fill(arr, -1);
    }
    
    public void put(int key, int value) {
        if (key >= arr.length) {
            resize(key + 1);   // expand just enough
        }
        arr[key] = value;
    }
    
    public int get(int key) {
        if(key >= arr.length || arr[key] == -1) {
            return -1;
        }
        return arr[key];
    }
    
    public void remove(int key) {
        if(key < arr.length) {
            arr[key] = -1;
        }
    }

    private void resize(int newSize) {
        int[] newArr = new int[newSize];
        Arrays.fill(newArr, -1);   // VERY IMPORTANT

        for (int i = 0; i < arr.length; i++) {
            newArr[i] = arr[i];
        }

        arr = newArr;
    }
}

/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap obj = new MyHashMap();
 * obj.put(key,value);
 * int param_2 = obj.get(key);
 * obj.remove(key);
 */
 
 
 https://leetcode.com/problems/find-all-anagrams-in-a-string/

 class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> output = new ArrayList<Integer>();
        int sCharMap[] = new int[26];
        int pCharMap[] = new int[26];
        int start = 0;
        for(int i = 0; i < p.length(); i++) {
            pCharMap[p.charAt(i) - 'a']++;
        }
        for(int i = 0; i < s.length(); i++) {
            sCharMap[s.charAt(i) -'a']++;
            if(i - start + 1 == p.length()) {
                if(compareForSame(sCharMap, pCharMap, p)) {
                    output.add(start);
                }
                sCharMap[s.charAt(start) - 'a']--;
                start++;
            }
        }
        return output;
    }

    public boolean compareForSame(int sCharMap[], int pCharMap[], String p) {
        for(int i = 0; i < p.length(); i++) {
            if(sCharMap[p.charAt(i) - 'a'] != pCharMap[p.charAt(i) - 'a']
             ) {
                return false;
            }
        }
        return true;     
    }
}


https://leetcode.com/problems/logger-rate-limiter/



https://leetcode.com/problems/minimum-window-substring/

//slightly tricky
//the idea is sliding window
//loop through the string
//if the char is already present
// increment start..remove the start char from the hashmap
// else 
//	calculate max = Math.max(max, i - start + 1);
//	increment the array loop

class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer > charPlacement = new HashMap<Character, Integer>();
        int max = 0;
        int start = 0;
        if(s.length() == 1) {
            return 1;
        }
        for(int i = 0; i < s.length(); ) {
            if(charPlacement.containsKey(s.charAt(i))) {
                charPlacement.remove(s.charAt(start));
                start++;
            } else {
                max = Math.max(max, i - start + 1 );
                charPlacement.put(s.charAt(i), i);
                i++;
            }
        }
        return max;
    }
}

https://leetcode.com/problems/permutation-in-string/

class Solution {
    //key points :
    // we need to see if s1 (combination) is present in s2
    // setup charItem array 
    // load s1 count to the charItem
    // assignRequired as count of s1
    // setup start = end = 0 ( sliding window)
    // loop through s2 string
    // reduce the charItem count of the character
    //key is if(charItem[s2.charAt(end) -'a'] > 0) { required--;}
    // if (end - start + 1 > s1.length)
    // ideally we are removing the start variable from charItem only if its >= 0
    //if(charItem[s2.charAt(start) -'a'] >= 0) , increment start , required 
    //   if required == 0,  return true
    public boolean checkInclusion(String s1, String s2) {
        int[] charItem = new int[26];
        int required = 0;
        int start = 0 , end = 0;
        if(s1.length() > s2.length()) {
            return false;
        }
        for(int i = 0; i < s1.length(); i++) {
            charItem[s1.charAt(i) - 'a']++;
        }
        required = s1.length();
        while(end < s2.length()) {
            if(charItem[s2.charAt(end) -'a'] > 0) {
                required--;
            }
            charItem[s2.charAt(end) -'a']--;
            if(end - start + 1 > s1.length()) {
                if(charItem[s2.charAt(start) -'a'] >= 0) {
                    required++;
                }
                charItem[s2.charAt(start) -'a']++;
                start++;
            }
            if(required == 0) {
                return true;
            }
            end++;
        }
        return false;
    }
}
