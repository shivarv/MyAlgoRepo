https://leetcode.com/problems/maximum-subarray/
class Solution {
    public int maxSubArray(int[] nums) {
        int sum = nums[0];
        int currentSum = nums[0];
        for(int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            sum = Math.max(currentSum, sum);
        }
        return sum;
    }
}


https://leetcode.com/problems/subarray-sum-equals-k/

class Solution {
    public int subarraySum(int[] nums, int k) {
        int countOfSubArray = 0;
        int sum = 0;
        Map<Integer, Integer> numsMap = new HashMap<Integer, Integer>();
        for(int i = 0 ; i < nums.length; i++) {
            sum += nums[i];
            if(sum == k) {
                countOfSubArray++;
            }
            //it has to be sum - k only then numbers between it will be sum to k
            if(numsMap.containsKey(sum - k)) {
                countOfSubArray += numsMap.get(sum - k);
            }
            numsMap.put(sum, numsMap.getOrDefault(sum, 0) + 1);
        }
        return countOfSubArray;
    }
}

https://leetcode.com/problems/subarray-sums-divisible-by-k/
    class Solution {
        public int subarraysDivByK(int[] nums, int k) {
            int totalCount = 0;
            int sum = 0;
            Map<Integer, Integer> numsMap = new HashMap<Integer, Integer>();
            for(int i = 0 ;i < nums.length; i++) {
                sum = ((sum + nums[i]) % k + k) % k;
                if(sum == 0) {
                    totalCount++;
                }
				//this means if already sum exists
                if(numsMap.containsKey(sum)) {
                    totalCount = totalCount + numsMap.get(sum);
                }
                numsMap.put(sum, numsMap.getOrDefault(sum, 0) + 1);
                
                
            }
            return totalCount;
        }
    }
	
https://leetcode.com/problems/product-of-array-except-self/
	
	class Solution {
    public int[] productExceptSelf(int[] nums) {
        int preProd = 1;
        int postProd = 1;
        int output[] = new int[nums.length];
        for(int i = 0; i < nums.length; i++) {
            output[i] = preProd;
            preProd *= nums[i];
        }
        for(int i = nums.length - 1; i >= 0; i--) {
            output[i] = output[i] * postProd;
            postProd *= nums[i];
        }
        return output;
    }
}


https://leetcode.com/problems/merge-intervals/
static ArrayList<int[]> mergeOverlap(int[][] arr) {

        // Sort intervals based on start values
        Arrays.sort(arr, (a, b) -> Integer.compare(a[0], b[0]));

        ArrayList<int[]> res = new ArrayList<>();
        res.add(new int[]{arr[0][0], arr[0][1]});

        for (int i = 1; i < arr.length; i++) {
            int[] last = res.get(res.size() - 1);
            int[] curr = arr[i];

            // If current interval overlaps with the last merged interval,
            // merge them
            if (curr[0] <= last[1])
                last[1] = Math.max(last[1], curr[1]);
            else
                res.add(new int[]{curr[0], curr[1]});
        }

        return res;
    }
	
	https://leetcode.com/problems/insert-interval/

	
	
	https://leetcode.com/problems/trapping-rain-water/

	// key point on why this works.. because Min(lmax or rMax) only be considered for the amount cal
	// left <= right
	// lMax <= rMax
	//for lMax greater ,calculate using left, rMax greater calculate using right
	class Solution {
    public int trap(int[] height) {
        int waterCount = 0;
        int lMax = height[0];
        int rMax = height[height.length - 1];
        int left = 1;
        int right = height.length - 1;
        while(left <= right) {
            if (lMax <= rMax) {
                if (height[left] < lMax) {
                    waterCount += lMax - height[left];
                }
                lMax = Math.max(lMax, height[left]);
                left++;
            } else {
                if (height[right] < rMax) {
                    waterCount += rMax - height[right];
                }
                rMax = Math.max(rMax, height[right]);
                right--;
            }
        }
        return waterCount;
    }
}

https://leetcode.com/problems/next-permutation/

class Solution {
    private void reverse(int[] nums, int left , int right) {
        
        while(left < right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }

    public void nextPermutation(int[] nums) {
        int firstNonIncrementingIndex = -1;
        //
        for(int i = nums.length - 2; i >= 0; i--) {
            if(nums[i] < nums[i + 1]) {
                firstNonIncrementingIndex = i;
                break;
            }
        }

        System.out.println(firstNonIncrementingIndex);
        if(firstNonIncrementingIndex == -1) {
            reverse(nums, 0 , nums.length - 1);
            return;
        }
        for(int i = nums.length - 1;i > firstNonIncrementingIndex; i--) {
            if(nums[i] > nums[firstNonIncrementingIndex]) {
                int temp = nums[i];
                nums[i] = nums[firstNonIncrementingIndex];
                nums[firstNonIncrementingIndex] = temp;
                break;
            }
        }
                System.out.println(Arrays.toString(nums));
                            reverse(nums, firstNonIncrementingIndex + 1, nums.length - 1);
        System.out.println(Arrays.toString(nums));
    }
}

https://leetcode.com/problems/rotate-array/

class Solution {
    public void rotate(int[] nums, int k) {
        if(nums.length <= 1) {
            return;
        }
        k = k % nums.length;
        reverseArray(nums, 0, nums.length - 1);
        reverseArray(nums, 0, k -1);
        reverseArray(nums, k, nums.length - 1);
        
    }

    private void reverseArray(int[] nums, int start, int end) {
        while(start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}


https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

class Solution {
    public int maxProfit(int[] prices) {
        int buy = 0;
        int sell = 1;
        int profit = 0;
        for(int i = 1; i < prices.length; i++ ) {
            profit = Math.max(profit, prices[sell] - prices[buy]);
            if(prices[sell] < prices[buy]) {
                buy = sell;
            }
            sell++;
        }
        return profit;
    }
}
//my approach
public int maxProfit(int[] prices) {
        int buy = prices[0];
        int profit = 0;
        for(int i = 1; i < prices.length; i++) {
            profit = Math.max(profit, prices[i] - buy);
            buy = Math.min(buy, prices[i]);
        }
        return profit;
}




https://leetcode.com/problems/majority-element/

// if we are asked for no spacecomplexity
//sort the array
//return the n/ 2 element..for 1 , 2 , 2, 4...if sorted n/ 2 = arr[2] = 2, if its 1, 2 , 2 .. n/ 2 = 1..arr[1] = 2
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> countMap = new HashMap<Integer, Integer>();
        int countValue = 0 ;
        // for 4 , half value is more than 2..for 3 ,half value is more than 1
        int halfValue = nums.length  % 2 == 0 ? nums.length / 2 : (nums.length - 1) / 2;
        for(int i = 0; i < nums.length; i++) {
            countValue = countMap.getOrDefault(nums[i], 0) + 1;
            if(countValue > halfValue) {
                return nums[i];
            }
            countMap.put(nums[i], countValue);
        }
        return -1;
    }
}

https://leetcode.com/problems/find-the-duplicate-number/

class Solution {
    public int findDuplicate(int[] nums) {
        //flyod's cycle
        int slowPointer = 0;
        int fastPointer = 0;
        int anotherSlowPointer = 0;
        // this logic gives the intersection of fastPointer and slowPointer
        while(true) {
            slowPointer = nums[slowPointer];
            fastPointer = nums[nums[fastPointer]];
            if(slowPointer == fastPointer) {
                break;
            }
        }
        //this gives us to identify the start of loop
        //the start of loop is the number 
        while(anotherSlowPointer != fastPointer) {
            anotherSlowPointer = nums[anotherSlowPointer];
            fastPointer = nums[fastPointer];
        }
        return anotherSlowPointer;

    }
}

class Solution {
    public int findDuplicate(int[] nums) {
        HashMap<Integer, Boolean> numsMap = new HashMap<Integer, Boolean>();
        for(int i = 0; i < nums.length;i++) {
            if(numsMap.containsKey(nums[i])) {
                return nums[i];
            }
            numsMap.put(nums[i], true);
        }
        return -1;
    }
}


https://leetcode.com/problems/set-matrix-zeroes/

//optimal solution is more better .

class Solution {
    public void setZeroes(int[][] matrix) {
        Set<Integer> xSet = new TreeSet<Integer>();
        Set<Integer> ySet = new TreeSet<Integer>();
        for(int i = 0 ; i < matrix.length;i++) {
            for(int j = 0; j < matrix[i].length; j++) {
                if(matrix[i][j] == 0) {
                    xSet.add(i);
                    ySet.add(j);
                }
            }
        }
        for(Integer yValue: ySet) {
            for(int i = 0; i < matrix.length; i++) {
                matrix[i][yValue] = 0;
            }
        }
        for(Integer xValue: xSet) {
            for(int j = 0; j < matrix[0].length; j++) {
                matrix[xValue][j] = 0;
            }
        }
    }
}

https://leetcode.com/problems/longest-mountain-in-array/

public int longestMountain(int[] arr) {
	int max = 0;
	int peak = 0;
	int leftValley = 0;
	int rightValley = 0;
	//starts with 1 and ends before arr.length - 1
	for(int i = 1; i < arr.length - 1; ) {
		if(arr[i-1] < arr[i] && arr[i] > arr[i + 1]) {
			peak = i;
			leftValley = i;
			rightValley = i;
			while(leftValley >= 1 && arr[leftValley] > arr[leftValley - 1]) {
				leftValley--;
			}
			while(rightValley < arr.length - 1 && arr[rightValley] > arr[rightValley + 1]) {
				rightValley++;
			}
			max = Math.max(rightValley - leftValley + 1, max);
			i = rightValley + 1;
		} else {
			i++;
		}
	   
	}
	return max;
}
	
https://leetcode.com/problems/two-sum/
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> setMap = new HashMap<Integer, Integer>();
        for(int i = 0; i < nums.length;i++) {
            if(setMap.containsKey(target - nums[i])) {
                return new int[]{i, setMap.get(target - nums[i]) };
            } else {
                setMap.put(nums[i], i);
            }
        }
        return new int[]{-1, -1};
    }
}

https://leetcode.com/problems/group-anagrams/
//one other algorithm is sorting each item and then seeing everyitem which is same
class Solution {
    public static String createHash(String str) {
        int[] charSet = new int[26];
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < str.length(); i++) {
            charSet[str.charAt(i) - 'a']++;
        }
        for(int i = 0; i < 26; i++) {
            if(charSet[i] > 0) {
                sb.append((char) ('a' + i));
                sb.append(charSet[i]);
                sb.append('$');
            }
        }
        return sb.toString();
    }

    public List<List<String>> groupAnagrams(String[] strs) {
       List<List<String>> output = new ArrayList<>();
       HashMap<String, List<String>> hashMapData = new HashMap<String, List<String>>();
       for(int i = 0; i < strs.length; i++) {
            String hashString = createHash(strs[i]);
            List<String> loopOutput = hashMapData.getOrDefault(hashString, new ArrayList<String>());
            loopOutput.add(strs[i]);
            hashMapData.put(hashString, loopOutput);
       }
        for (Map.Entry<String, List<String>> entry : hashMapData.entrySet())    {
            String key = entry.getKey();
            output.add(entry.getValue());
        }
        return output;
    }
}

https://leetcode.com/problems/longest-consecutive-sequence/

class Solution {
    public int longestConsecutive(int[] nums) {
        int maxSequence = 0;
        int sequence = 1;
        HashSet<Integer> numsSet = new HashSet<Integer>();
        for(int num: nums) {
            numsSet.add(num);
        }
        //avoid for loop of nums because it can have duplicates
        //always loop through set to avoid redoing duplicate nums
        for(int num: numsSet) {
			// num - 1 check is needed because only then it makes our code is checking begining of a sequence
			// if 3 exists already and our loop is at 4, we should avoid going to check for sequence at 4
            if(!numsSet.contains(num - 1)) {
                sequence = 1;
                while(numsSet.contains(num + sequence)) {
                    sequence++;   
                }
                // we allow even 1 item
                maxSequence = Math.max(maxSequence, sequence);
            }   
        }
        return maxSequence;
    }
}


https://leetcode.com/problems/top-k-frequent-elements/

class Solution {
    public int[] topKFrequent(int[] nums, int k) {

        Map<Integer, Integer> countMap = new HashMap<>();

        // 1️⃣ Count frequency
        for (int num : nums) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }

        // 2️⃣ Create buckets (max frequency <= nums.length)
        List<List<Integer>> buckets = new ArrayList<>();

		// <= nums.length is important step , else buckets.get(freq) can throw exception
		// eg for [1] as inputs
        for (int i = 0; i <= nums.length; i++) {
            buckets.add(new ArrayList<>());
        }

        // 3️⃣ Fill buckets
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            int num = entry.getKey();
            int freq = entry.getValue();
            buckets.get(freq).add(num);
        }

        // 4️⃣ Collect top k from highest frequency
        int[] result = new int[k];
        int index = 0;

        for (int i = buckets.size() - 1; i >= 0 && index < k; i--) {
            for (int num : buckets.get(i)) {
                result[index++] = num;
                if (index == k) break;
            }
        }

        return result;
    }
}