https://leetcode.com/problems/maximum-subarray/
class Solution {
    public int maxSubArray(int[] nums) {
        int sum = nums[0];
        int currentSum = nums[0];
        for(int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            sum = Math.max(currentSum, sum);
        }
        return sum;
    }
}


https://leetcode.com/problems/subarray-sum-equals-k/

class Solution {
    public int subarraySum(int[] nums, int k) {
        int countOfSubArray = 0;
        int sum = 0;
        Map<Integer, Integer> numsMap = new HashMap<Integer, Integer>();
        for(int i = 0 ; i < nums.length; i++) {
            sum += nums[i];
            if(sum == k) {
                countOfSubArray++;
            }
            //it has to be sum - k only then numbers between it will be sum to k
            if(numsMap.containsKey(sum - k)) {
                countOfSubArray += numsMap.get(sum - k);
            }
            numsMap.put(sum, numsMap.getOrDefault(sum, 0) + 1);
        }
        return countOfSubArray;
    }
}

https://leetcode.com/problems/subarray-sums-divisible-by-k/
    class Solution {
        public int subarraysDivByK(int[] nums, int k) {
            int totalCount = 0;
            int sum = 0;
            Map<Integer, Integer> numsMap = new HashMap<Integer, Integer>();
            for(int i = 0 ;i < nums.length; i++) {
                sum = ((sum + nums[i]) % k + k) % k;
                if(sum == 0) {
                    totalCount++;
                }
				//this means if already sum exists
                if(numsMap.containsKey(sum)) {
                    totalCount = totalCount + numsMap.get(sum);
                }
                numsMap.put(sum, numsMap.getOrDefault(sum, 0) + 1);
                
                
            }
            return totalCount;
        }
    }
	
https://leetcode.com/problems/product-of-array-except-self/
	
	class Solution {
    public int[] productExceptSelf(int[] nums) {
        int preProd = 1;
        int postProd = 1;
        int output[] = new int[nums.length];
        for(int i = 0; i < nums.length; i++) {
            output[i] = preProd;
            preProd *= nums[i];
        }
        for(int i = nums.length - 1; i >= 0; i--) {
            output[i] = output[i] * postProd;
            postProd *= nums[i];
        }
        return output;
    }
}


https://leetcode.com/problems/merge-intervals/
static ArrayList<int[]> mergeOverlap(int[][] arr) {

        // Sort intervals based on start values
        Arrays.sort(arr, (a, b) -> Integer.compare(a[0], b[0]));

        ArrayList<int[]> res = new ArrayList<>();
        res.add(new int[]{arr[0][0], arr[0][1]});

        for (int i = 1; i < arr.length; i++) {
            int[] last = res.get(res.size() - 1);
            int[] curr = arr[i];

            // If current interval overlaps with the last merged interval,
            // merge them
            if (curr[0] <= last[1])
                last[1] = Math.max(last[1], curr[1]);
            else
                res.add(new int[]{curr[0], curr[1]});
        }

        return res;
    }
	
	https://leetcode.com/problems/insert-interval/

	
	
	https://leetcode.com/problems/trapping-rain-water/

	// key point on why this works.. because Min(lmax or rMax) only be considered for the amount cal
	// left <= right
	// lMax <= rMax
	//for lMax greater ,calculate using left, rMax greater calculate using right
	class Solution {
    public int trap(int[] height) {
        int waterCount = 0;
        int lMax = height[0];
        int rMax = height[height.length - 1];
        int left = 1;
        int right = height.length - 1;
        while(left <= right) {
            if (lMax <= rMax) {
                if (height[left] < lMax) {
                    waterCount += lMax - height[left];
                }
                lMax = Math.max(lMax, height[left]);
                left++;
            } else {
                if (height[right] < rMax) {
                    waterCount += rMax - height[right];
                }
                rMax = Math.max(rMax, height[right]);
                right--;
            }
        }
        return waterCount;
    }
}

https://leetcode.com/problems/next-permutation/

class Solution {
    private void reverse(int[] nums, int left , int right) {
        
        while(left < right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }

    public void nextPermutation(int[] nums) {
        int firstNonIncrementingIndex = -1;
        //
        for(int i = nums.length - 2; i >= 0; i--) {
            if(nums[i] < nums[i + 1]) {
                firstNonIncrementingIndex = i;
                break;
            }
        }

        System.out.println(firstNonIncrementingIndex);
        if(firstNonIncrementingIndex == -1) {
            reverse(nums, 0 , nums.length - 1);
            return;
        }
        for(int i = nums.length - 1;i > firstNonIncrementingIndex; i--) {
            if(nums[i] > nums[firstNonIncrementingIndex]) {
                int temp = nums[i];
                nums[i] = nums[firstNonIncrementingIndex];
                nums[firstNonIncrementingIndex] = temp;
                break;
            }
        }
                System.out.println(Arrays.toString(nums));
                            reverse(nums, firstNonIncrementingIndex + 1, nums.length - 1);
        System.out.println(Arrays.toString(nums));
    }
}

https://leetcode.com/problems/rotate-array/

class Solution {
    public void rotate(int[] nums, int k) {
        if(nums.length <= 1) {
            return;
        }
        k = k % nums.length;
        reverseArray(nums, 0, nums.length - 1);
        reverseArray(nums, 0, k -1);
        reverseArray(nums, k, nums.length - 1);
        
    }

    private void reverseArray(int[] nums, int start, int end) {
        while(start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}


https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

class Solution {
    public int maxProfit(int[] prices) {
        int buy = 0;
        int sell = 1;
        int profit = 0;
        for(int i = 1; i < prices.length; i++ ) {
            profit = Math.max(profit, prices[sell] - prices[buy]);
            if(prices[sell] < prices[buy]) {
                buy = sell;
            }
            sell++;
        }
        return profit;
    }
}
//my approach
public int maxProfit(int[] prices) {
        int buy = prices[0];
        int profit = 0;
        for(int i = 1; i < prices.length; i++) {
            profit = Math.max(profit, prices[i] - buy);
            buy = Math.min(buy, prices[i]);
        }
        return profit;
}




https://leetcode.com/problems/majority-element/

// if we are asked for no spacecomplexity
//sort the array
//return the n/ 2 element..for 1 , 2 , 2, 4...if sorted n/ 2 = arr[2] = 2, if its 1, 2 , 2 .. n/ 2 = 1..arr[1] = 2
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> countMap = new HashMap<Integer, Integer>();
        int countValue = 0 ;
        // for 4 , half value is more than 2..for 3 ,half value is more than 1
        int halfValue = nums.length  % 2 == 0 ? nums.length / 2 : (nums.length - 1) / 2;
        for(int i = 0; i < nums.length; i++) {
            countValue = countMap.getOrDefault(nums[i], 0) + 1;
            if(countValue > halfValue) {
                return nums[i];
            }
            countMap.put(nums[i], countValue);
        }
        return -1;
    }
}

https://leetcode.com/problems/find-the-duplicate-number/

class Solution {
    public int findDuplicate(int[] nums) {
        //flyod's cycle
        int slowPointer = 0;
        int fastPointer = 0;
        int anotherSlowPointer = 0;
        // this logic gives the intersection of fastPointer and slowPointer
        while(true) {
            slowPointer = nums[slowPointer];
            fastPointer = nums[nums[fastPointer]];
            if(slowPointer == fastPointer) {
                break;
            }
        }
        //this gives us to identify the start of loop
        //the start of loop is the number 
        while(anotherSlowPointer != fastPointer) {
            anotherSlowPointer = nums[anotherSlowPointer];
            fastPointer = nums[fastPointer];
        }
        return anotherSlowPointer;

    }
}

class Solution {
    public int findDuplicate(int[] nums) {
        HashMap<Integer, Boolean> numsMap = new HashMap<Integer, Boolean>();
        for(int i = 0; i < nums.length;i++) {
            if(numsMap.containsKey(nums[i])) {
                return nums[i];
            }
            numsMap.put(nums[i], true);
        }
        return -1;
    }
}


https://leetcode.com/problems/set-matrix-zeroes/
class Solution {
    public void setZeroes(int[][] matrix) {
        Set<Integer> xSet = new TreeSet<Integer>();
        Set<Integer> ySet = new TreeSet<Integer>();
        for(int i = 0 ; i < matrix.length;i++) {
            for(int j = 0; j < matrix[i].length; j++) {
                if(matrix[i][j] == 0) {
                    xSet.add(i);
                    ySet.add(j);
                }
            }
        }
        for(Integer yValue: ySet) {
            for(int i = 0; i < matrix.length; i++) {
                matrix[i][yValue] = 0;
            }
        }
        for(Integer xValue: xSet) {
            for(int j = 0; j < matrix[0].length; j++) {
                matrix[xValue][j] = 0;
            }
        }
    }
}